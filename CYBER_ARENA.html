<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Cyberpunk Arena Survival</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #050510;
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
            cursor: crosshair;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.2);
            background: linear-gradient(to bottom, #101015, #201c35, #151520);
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            text-shadow: 2px 2px 0 #000;
            font-size: 20px;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 5;
        }

        .stat-row {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .bar-container {
            border: 2px solid #fff;
            width: 200px;
            height: 16px;
            background: #000;
        }
        #hp-bar {
            width: 100%;
            height: 100%;
            background: #ff00ff;
            box-shadow: 0 0 10px #ff00ff;
            transition: width 0.1s;
        }

        #ammo-val {
            color: #ffff00;
            font-weight: bold;
            font-size: 24px;
            text-shadow: 0 0 10px #ffff00;
        }

        #weapon-name {
            color: #00ffff;
            font-weight: bold;
            font-size: 24px;
            text-shadow: 0 0 10px #00ffff;
            text-transform: uppercase;
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 16, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        h1 {
            font-size: 50px;
            color: #00ffff;
            text-shadow: 0 0 20px #00ffff, 3px 3px 0 #000;
            margin-bottom: 20px;
            text-transform: uppercase;
            text-align: center;
            letter-spacing: 5px;
        }

        h2 {
            font-size: 30px;
            color: #ff00ff;
            margin-bottom: 20px;
        }

        button {
            background: rgba(0,0,0,0.5);
            border: 2px solid #00ffff;
            color: #00ffff;
            padding: 15px 40px;
            font-size: 20px;
            font-family: inherit;
            cursor: pointer;
            text-transform: uppercase;
            margin: 10px;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
            transition: 0.2s;
        }

        button:hover {
            background: #00ffff;
            color: #000;
            box-shadow: 0 0 30px #00ffff;
        }

        .hidden { display: none !important; }

        .scanlines {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%);
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 99;
            opacity: 0.3;
        }

        #wave-notification {
            position: absolute;
            top: 30%;
            width: 100%;
            text-align: center;
            font-size: 60px;
            color: #ff00ff;
            text-shadow: 0 0 20px #ff00ff;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="scanlines"></div>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="wave-notification">WAVE 1</div>

        <div id="ui-layer">
            <div class="stat-row">
                <span style="color:#ff00ff">HP:</span>
                <div class="bar-container"><div id="hp-bar"></div></div>
            </div>
            <div class="stat-row">
                <span style="color:#ffff00">AMMO:</span>
                <span id="ammo-val">30</span>
            </div>
            <div class="stat-row">
                <span style="color:#00ffff">WEAPON:</span>
                <span id="weapon-name">PISTOL</span>
            </div>
            <div id="level-display" style="font-size: 16px; color: #888; margin-top: 5px;">WAVE: <span id="wave-val" style="color:#fff">1</span></div>
            <div style="font-size: 14px; color: #666;">ENEMIES: <span id="enemy-count">0</span></div>
        </div>

        <div id="menu-screen" class="overlay">
            <h1>CYBER ARENA</h1>
            <button id="playBtn">ENTER COMBAT</button>
            <p style="color: #666; margin-top: 20px; font-size: 14px;">SURVIVE THE WAVES</p>
        </div>

        <div id="end-screen" class="overlay hidden">
            <h1 id="end-title">K.I.A.</h1>
            <h2 id="end-score">WAVE REACHED: 1</h2>
            <button id="retryBtn">RESTART</button>
        </div>
    </div>

    <script>
    (() => {
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const GW = 640;
        const GH = 360;
        const TILE_SIZE = 16;

        const mouse = { x: 0, y: 0, worldX: 0, worldY: 0, down: false };
        const keys = { w: false, a: false, s: false, d: false, space: false };

        const C = {
            NEON_BLUE: '#00ffff',
            NEON_PINK: '#ff00ff',
            NEON_YELLOW: '#ffff00',
            DARK_WALL: '#111',
            SPIKE: '#ff0000',
            ENEMY_RED: '#ff3333',
            ENEMY_TANK: '#cc00cc',
            ENEMY_CRAWLER: '#ffaa00'
        };

        function createSprite(pattern, colorMap, width) {
            const height = Math.ceil(pattern.length / width);
            const c = document.createElement('canvas');
            c.width = width;
            c.height = height;
            const cx = c.getContext('2d');
            for (let i = 0; i < pattern.length; i++) {
                const val = pattern[i];
                if (val !== 0) {
                    cx.fillStyle = colorMap[val];
                    cx.fillRect(i % width, Math.floor(i / width), 1, 1);
                }
            }
            return c;
        }

        // --- СПРАЙТЫ ---
        const P_DATA = [0,0,0,1,1,1,1,0,0,0,0,0, 0,0,1,1,1,1,1,1,0,0,0,0, 0,0,1,2,2,1,1,1,0,0,0,0, 0,0,1,1,1,1,1,1,0,0,0,0, 0,0,0,1,1,1,1,0,0,1,1,0, 0,0,0,1,1,1,1,1,1,3,3,0, 0,0,0,1,1,1,1,0,0,0,0,0, 0,0,1,1,0,0,1,1,0,0,0,0, 0,0,1,1,0,0,1,1,0,0,0,0, 0,0,1,0,0,0,0,1,0,0,0,0, 0,1,1,0,0,0,0,1,1,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0];
        const WALKER_DATA = [0,0,0,2,2,2,2,0,0,0,0,0, 0,0,2,2,2,2,2,2,0,0,0,0, 0,0,2,4,4,2,4,4,0,0,0,0, 0,0,2,2,2,2,2,2,0,0,0,0, 0,0,1,1,1,1,1,1,0,0,0,0, 0,0,1,1,1,1,1,1,3,3,3,0, 0,0,1,1,1,1,1,1,0,0,0,0, 0,0,1,1,0,0,1,1,0,0,0,0, 0,0,1,1,0,0,1,1,0,0,0,0, 0,0,1,0,0,0,0,1,0,0,0,0, 0,1,1,0,0,0,0,1,1,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0];
        const CRAWLER_DATA = [0,0,0,0,0,0,0,0,0,0, 0,0,4,0,0,0,0,4,0,0, 0,4,2,2,2,2,2,2,4,0, 4,2,5,5,2,2,5,5,2,4, 0,2,2,2,2,2,2,2,2,0, 0,1,0,1,0,0,1,0,1,0];
        const DRONE_DATA = [0,0,0,1,1,1,1,0,0,0, 0,1,1,2,2,2,2,1,1,0, 1,1,2,5,5,5,5,2,1,1, 0,1,2,5,5,5,5,2,1,0, 0,0,2,2,2,2,2,2,0,0, 0,0,0,1,3,3,1,0,0,0, 0,0,0,0,3,3,0,0,0,0];
        const TANK_DATA = [0,0,0,0,2,2,2,2,2,2,0,0,0,0, 0,0,0,2,2,2,2,2,2,2,2,0,0,0, 0,0,0,2,5,2,2,2,2,5,2,0,0,0, 0,0,0,1,1,1,1,1,1,1,1,0,0,0, 0,3,3,3,1,1,1,1,1,1,1,0,0,0, 0,3,3,3,1,1,1,1,1,1,1,0,0,0, 1,1,1,1,1,1,1,1,1,1,1,1,1,1, 1,0,1,0,1,0,1,1,0,1,0,1,0,1];
        const KAMI_DATA = [0,0,0,5,0,0,5,0,0,0, 0,0,5,2,2,2,2,5,0,0, 0,5,2,5,2,2,5,2,5,0, 5,2,2,2,5,5,2,2,2,5, 0,5,2,5,2,2,5,2,5,0, 0,0,5,2,2,2,2,5,0,0, 0,0,0,5,0,0,5,0,0,0];
        const A_DATA = [0,0,1,1,1,1,1,1,0,0, 0,1,2,2,2,2,2,2,1,0, 1,2,1,1,2,2,1,1,2,1, 1,2,1,1,2,2,1,1,2,1, 1,2,2,2,2,2,2,2,2,1, 1,2,1,1,1,1,1,1,2,1, 1,2,1,1,1,1,1,1,2,1, 1,2,2,2,2,2,2,2,2,1, 0,1,1,1,1,1,1,1,1,0, 0,0,0,0,0,0,0,0,0,0];
        const HP_DATA = [0,0,0,1,1,0,0,1,1,0,0,0, 0,0,1,2,2,1,1,2,2,1,0,0, 0,1,2,2,2,2,2,2,2,2,1,0, 0,1,2,2,2,2,2,2,2,2,1,0, 0,0,1,2,2,2,2,2,2,1,0,0, 0,0,0,1,2,2,2,2,1,0,0,0, 0,0,0,0,1,2,2,1,0,0,0,0, 0,0,0,0,0,1,1,0,0,0,0,0];
        // Weapon crate sprite (Blue)
        const WPN_DATA = [0,0,1,1,1,1,1,1,0,0, 0,1,3,3,3,3,3,3,1,0, 1,3,1,3,3,3,3,1,3,1, 1,3,1,1,1,1,1,1,3,1, 1,3,3,3,3,3,3,3,3,1, 1,3,1,3,3,3,3,1,3,1, 1,3,1,1,1,1,1,1,3,1, 1,3,3,3,3,3,3,3,3,1, 0,1,1,1,1,1,1,1,1,0, 0,0,0,0,0,0,0,0,0,0];

        const sprites = {
            player: createSprite(P_DATA, {1: C.NEON_BLUE, 2: '#fff', 3: '#555'}, 12),
            walker: createSprite(WALKER_DATA, {1: '#222', 2: '#444', 3: '#777', 4: 'red'}, 12),
            crawler: createSprite(CRAWLER_DATA, {1: '#222', 2: C.ENEMY_CRAWLER, 4: 'red', 5: '#fff'}, 10),
            drone: createSprite(DRONE_DATA, {1: '#444', 2: '#666', 3: 'red', 5: '#aaf'}, 10),
            tank: createSprite(TANK_DATA, {1: '#222', 2: C.ENEMY_TANK, 3: '#666', 5: 'red'}, 14),
            kami: createSprite(KAMI_DATA, {2: '#333', 5: 'orange'}, 10),
            ammo: createSprite(A_DATA, {1: '#440', 2: C.NEON_YELLOW}, 10),
            health: createSprite(HP_DATA, {1: '#400', 2: C.NEON_PINK}, 12),
            weapon: createSprite(WPN_DATA, {1: '#004', 3: C.NEON_BLUE}, 10)
        };

        const ARENA_MAP = [
            "############################################################",
            "#                                                          #",
            "#             ###                        ###               #",
            "#                                                          #",
            "#     ###             #####    #####               ###     #",
            "#                                                          #",
            "#               ###              ###                       #",
            "#                                            ###           #",
            "#      ####             ###                                #",
            "#                                                          #",
            "#               ###              #####        ###          #",
            "#                                                          #",
            "#      ###             ###               ###               #",
            "#                                                          #",
            "#             #####             #####                      #",
            "#                                                 ###      #",
            "#      ###                                                 #",
            "#                     ###           ###                    #",
            "#P                                                         #",
            "############################################################",
        ];

        // --- WEAPON CONFIG ---
        const WEAPONS = {
            PISTOL: { name: "PISTOL", rate: 250, dmg: 10, speed: 8, count: 1, spread: 0, auto: false, color: C.NEON_BLUE },
            SHOTGUN: { name: "SHOTGUN", rate: 800, dmg: 8, speed: 9, count: 5, spread: 0.4, auto: false, color: '#ffff00' },
            MINIGUN: { name: "MINIGUN", rate: 80, dmg: 4, speed: 10, count: 1, spread: 0.2, auto: true, color: '#ffaa00' },
            SMART:   { name: "SMART",   rate: 400, dmg: 15, speed: 6, count: 1, spread: 0.2, auto: true, homing: true, color: '#ff00ff' },
            RAILGUN: { name: "RAILGUN", rate: 1500, dmg: 50, speed: 15, count: 1, spread: 0, auto: false, pierce: true, color: '#00ffff' }
        };

        class Background {
            constructor() {
                this.stars = [];
                for(let i=0; i<80; i++) {
                    this.stars.push({x: Math.random()*GW, y: Math.random()*GH, s: Math.random()>0.8?2:1, a: Math.random()});
                }
                this.buildings = [];
                for(let i=0; i<20; i++) {
                    this.buildings.push({
                        x: i * 40 - 20,
                        w: 30 + Math.random()*20,
                        h: 50 + Math.random()*150,
                        c: i%2===0 ? '#0a0a10' : '#0e0e15'
                    });
                }
            }
            draw(ctx, camX, camY) {
                ctx.fillStyle = '#fff';
                this.stars.forEach(s => {
                    ctx.globalAlpha = 0.3 + Math.sin(Date.now()/500 + s.a)*0.2;
                    let sx = (s.x - camX * 0.05) % GW;
                    if (sx < 0) sx += GW;
                    let sy = (s.y - camY * 0.05) % GH;
                    if (sy < 0) sy += GH;
                    ctx.fillRect(sx, sy, s.s, s.s);
                });

                ctx.globalAlpha = 1;
                ctx.fillStyle = C.NEON_PINK;
                ctx.shadowColor = C.NEON_PINK;
                ctx.shadowBlur = 30;
                ctx.beginPath();
                ctx.arc(GW - 80, 60, 25, 0, Math.PI*2);
                ctx.fill();
                ctx.shadowBlur = 0;

                ctx.save();
                ctx.translate(0, GH);
                this.buildings.forEach(b => {
                    let bx = b.x - camX * 0.2;
                    while (bx < -b.w) bx += this.buildings.length * 40;
                    while (bx > GW) bx -= this.buildings.length * 40;

                    if (bx > -b.w && bx < GW) {
                        ctx.fillStyle = b.c;
                        ctx.fillRect(bx, -b.h - (camY*0.1), b.w, b.h + 200);

                        ctx.fillStyle = 'rgba(0, 255, 255, 0.1)';
                        if (b.h > 80) {
                            for(let wy=10; wy<b.h-10; wy+=15) {
                                if (Math.random()>0.2) ctx.fillRect(bx+5, -b.h+wy - (camY*0.1), 4, 8);
                            }
                        }
                    }
                });
                ctx.restore();
            }
        }

        class Game {
            constructor() {
                this.state = 'MENU';
                this.entities = [];
                this.particles = [];
                this.map = [];
                this.validSpawnPoints = [];
                this.camera = { x: 0, y: 0 };
                this.shake = 0;
                this.bg = new Background();

                this.wave = 1;
                this.waveTimer = 0;
                this.enemiesToSpawn = [];
                this.spawnTimer = 0;
                this.supplyTimer = 0;

                this.loop = this.loop.bind(this);
                this.resize();
                window.addEventListener('resize', () => this.resize());
                requestAnimationFrame(this.loop);
            }

            resize() {
                const aspect = GW / GH;
                let w = window.innerWidth, h = window.innerHeight;
                if (w / h < aspect) h = w / aspect; else w = h * aspect;
                canvas.style.width = w + 'px';
                canvas.style.height = h + 'px';
                canvas.width = GW;
                canvas.height = GH;
            }

            startGame() {
                this.entities = [];
                this.particles = [];
                this.loadMap(ARENA_MAP);
                this.state = 'PLAY';
                this.wave = 0;
                this.supplyTimer = Date.now() + 5000;
                this.startNextWave();
                document.getElementById('menu-screen').classList.add('hidden');
                document.getElementById('end-screen').classList.add('hidden');
            }

            startNextWave() {
                this.wave++;
                document.getElementById('wave-val').innerText = this.wave;

                const notif = document.getElementById('wave-notification');
                notif.innerText = `WAVE ${this.wave}`;
                notif.style.opacity = 1;
                setTimeout(() => notif.style.opacity = 0, 2000);

                this.enemiesToSpawn = [];
                const count = 5 + Math.floor(this.wave * 2);

                for(let i=0; i<count; i++) {
                    const r = Math.random();
                    if (r < 0.4) this.enemiesToSpawn.push('crawler');
                    else if (r < 0.7) this.enemiesToSpawn.push('walker');
                    else if (r < 0.85) this.enemiesToSpawn.push('drone');
                    else if (r < 0.95) this.enemiesToSpawn.push('kami');
                    else this.enemiesToSpawn.push('tank');

                    if (this.wave > 3 && i === 0) this.enemiesToSpawn.push('tank');
                    if (this.wave > 2 && i === 1) this.enemiesToSpawn.push('drone');
                }
            }

            spawnEnemy() {
                if (this.enemiesToSpawn.length === 0) return;

                const type = this.enemiesToSpawn.pop();
                let x, y;

                if (['walker', 'tank', 'crawler'].includes(type)) {
                    if (this.validSpawnPoints.length > 0) {
                        const spot = this.validSpawnPoints[Math.floor(Math.random() * this.validSpawnPoints.length)];
                        x = spot.x * TILE_SIZE;
                        y = (spot.y - 1) * TILE_SIZE;
                    } else {
                        x = 100 + Math.random() * (this.mapW * TILE_SIZE - 200);
                        y = 100;
                    }
                } else {
                    x = 100 + Math.random() * (this.mapW * TILE_SIZE - 200);
                    y = 50 + Math.random() * 100;
                }

                let enemy;
                if (type === 'crawler') enemy = new Crawler(x, y);
                else if (type === 'walker') enemy = new Walker(x, y);
                else if (type === 'drone') enemy = new Drone(x, y);
                else if (type === 'tank') enemy = new Tank(x, y);
                else if (type === 'kami') enemy = new Kamikaze(x, y);

                this.entities.push(enemy);
                for(let k=0; k<10; k++) this.particles.push(new Particle(x, y, '#fff'));
            }

            spawnSupply() {
                if (this.validSpawnPoints.length === 0) return;
                const spot = this.validSpawnPoints[Math.floor(Math.random() * this.validSpawnPoints.length)];
                const x = spot.x * TILE_SIZE;
                const y = (spot.y - 1) * TILE_SIZE;

                // Periodic supply is just standard stuff
                if (Math.random() < 0.5) this.entities.push(new HealthPickup(x, y));
                else this.entities.push(new AmmoPickup(x, y));

                for(let i=0; i<15; i++) this.particles.push(new Particle(x+8, y+8, '#ffff00'));
            }

            spawnWeapon(x, y) {
                // Random weapon except pistol
                const types = ['SHOTGUN', 'MINIGUN', 'SMART', 'RAILGUN'];
                const w = types[Math.floor(Math.random() * types.length)];
                this.entities.push(new WeaponPickup(x, y, w));
                for(let i=0; i<15; i++) this.particles.push(new Particle(x+5, y+5, C.NEON_BLUE));
            }

            loadMap(mapData) {
                this.map = [];
                this.validSpawnPoints = [];
                this.mapH = mapData.length;
                this.mapW = mapData[0].length;
                for (let y = 0; y < this.mapH; y++) {
                    let row = [];
                    for (let x = 0; x < this.mapW; x++) {
                        const c = mapData[y][x];
                        let t = 0;
                        if (c === '#') t = 1;
                        else if (c === '^') t = 2;

                        if (c === 'P') {
                            this.player = new Player(x*TILE_SIZE, y*TILE_SIZE);
                            this.entities.push(this.player);
                        }

                        if (y > 0 && y < this.mapH - 1 && c === '#' && mapData[y-1][x] === ' ') {
                            this.validSpawnPoints.push({x: x, y: y});
                        }

                        row.push(t);
                    }
                    this.map.push(row);
                }
            }

            update() {
                if (this.state !== 'PLAY') return;

                if (this.enemiesToSpawn.length > 0 && Date.now() - this.spawnTimer > 800) {
                    this.spawnEnemy();
                    this.spawnTimer = Date.now();
                }

                if (Date.now() > this.supplyTimer) {
                    this.spawnSupply();
                    this.supplyTimer = Date.now() + 15000;
                }

                const enemiesAlive = this.entities.filter(e => e.type === 'enemy').length;
                document.getElementById('enemy-count').innerText = enemiesAlive + this.enemiesToSpawn.length;

                if (enemiesAlive === 0 && this.enemiesToSpawn.length === 0) {
                    this.startNextWave();
                }

                if (this.player) {
                    const tx = this.player.x + 6 - GW/2;
                    const ty = this.player.y + 6 - GH/2;
                    this.camera.x += (tx - this.camera.x) * 0.1;
                    this.camera.y += (ty - this.camera.y) * 0.1;
                    this.camera.x = Math.max(0, Math.min(this.camera.x, this.mapW*TILE_SIZE - GW));
                    this.camera.y = Math.max(0, Math.min(this.camera.y, this.mapH*TILE_SIZE - GH));
                }

                if (this.shake > 0) this.shake *= 0.9;

                const rect = canvas.getBoundingClientRect();
                const scaleX = GW / rect.width;
                const scaleY = GH / rect.height;
                mouse.worldX = (mouse.x - rect.left) * scaleX + this.camera.x;
                mouse.worldY = (mouse.y - rect.top) * scaleY + this.camera.y;

                for (let i = this.entities.length - 1; i >= 0; i--) {
                    const e = this.entities[i];
                    e.update(this.map, this.entities);
                    if (e.dead) {
                        if (e === this.player) this.loseGame();

                        // Enemy drops
                        if (e.type === 'enemy') {
                            const rand = Math.random();
                            if (rand < 0.1) this.spawnWeapon(e.x, e.y); // 10% weapon drop
                            else if (rand < 0.2) this.entities.push(new AmmoPickup(e.x, e.y)); // 10% ammo
                            else if (rand < 0.25) this.entities.push(new HealthPickup(e.x, e.y)); // 5% health
                        }

                        this.entities.splice(i, 1);
                    }
                }

                for (let i = this.particles.length - 1; i >= 0; i--) {
                    this.particles[i].update();
                    if (this.particles[i].life <= 0) this.particles.splice(i, 1);
                }

                if (mouse.down && this.player && !this.player.dead) {
                    this.player.tryShoot();
                }

                this.updateUI();
            }

            updateUI() {
                if(this.player) {
                    document.getElementById('hp-bar').style.width = Math.max(0, (this.player.hp/this.player.maxHp*100))+'%';
                    const ammoEl = document.getElementById('ammo-val');
                    ammoEl.innerText = this.player.ammo;
                    ammoEl.style.color = this.player.ammo === 0 ? '#ff0000' : '#ffff00';

                    document.getElementById('weapon-name').innerText = this.player.weapon.name;
                    document.getElementById('weapon-name').style.color = this.player.weapon.color;
                }
            }

            draw() {
                ctx.clearRect(0,0,GW,GH);
                this.bg.draw(ctx, this.camera.x, this.camera.y);

                ctx.save();
                let dx = (Math.random()-0.5)*this.shake;
                let dy = (Math.random()-0.5)*this.shake;
                ctx.translate(-Math.floor(this.camera.x)+dx, -Math.floor(this.camera.y)+dy);

                const sc = Math.floor(this.camera.x/TILE_SIZE);
                const ec = sc + (GW/TILE_SIZE) + 2;
                const sr = Math.floor(this.camera.y/TILE_SIZE);
                const er = sr + (GH/TILE_SIZE) + 2;

                for (let y = sr; y <= er; y++) {
                    for (let x = sc; x <= ec; x++) {
                        if (y>=0 && y<this.mapH && x>=0 && x<this.mapW) {
                            if (this.map[y]) {
                                const t = this.map[y][x];
                                const px = x*TILE_SIZE, py = y*TILE_SIZE;
                                if (t === 1) {
                                    ctx.fillStyle = '#050505';
                                    ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                                    ctx.strokeStyle = '#333';
                                    ctx.strokeRect(px+0.5, py+0.5, TILE_SIZE-1, TILE_SIZE-1);
                                    ctx.fillStyle = C.NEON_BLUE;
                                    ctx.fillRect(px, py, TILE_SIZE, 2);
                                    ctx.shadowColor = C.NEON_BLUE;
                                    ctx.shadowBlur = 5;
                                    ctx.fillRect(px, py, TILE_SIZE, 1);
                                    ctx.shadowBlur = 0;
                                } else if (t === 2) {
                                    ctx.fillStyle = C.SPIKE;
                                    ctx.beginPath();
                                    ctx.moveTo(px, py+TILE_SIZE); ctx.lineTo(px+8, py+2); ctx.lineTo(px+16, py+TILE_SIZE);
                                    ctx.fill();
                                }
                            }
                        }
                    }
                }

                this.entities.forEach(e => e.draw(ctx));
                this.particles.forEach(p => p.draw(ctx));

                if (this.player && !this.player.dead) {
                    ctx.strokeStyle = 'rgba(255, 0, 0, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(this.player.x+6, this.player.y+6);
                    ctx.lineTo(mouse.worldX, mouse.worldY);
                    ctx.stroke();
                }

                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(mouse.worldX, mouse.worldY, 4, 0, Math.PI*2);
                ctx.stroke();

                ctx.restore();
            }

            loop() {
                this.update();
                this.draw();
                requestAnimationFrame(this.loop);
            }

            loseGame() {
                this.state = 'GAMEOVER';
                document.getElementById('end-score').innerText = `WAVE REACHED: ${this.wave}`;
                document.getElementById('end-screen').classList.remove('hidden');
            }
        }

        class Entity {
            constructor(x, y, w, h, type) {
                this.x = x; this.y = y; this.w = w; this.h = h;
                this.vx = 0; this.vy = 0; this.type = type;
                this.dead = false; this.grounded = false;
            }
            checkMap(map, dx, dy) {
                const nx = this.x + dx, ny = this.y + dy;
                const pts = [{x:nx, y:ny}, {x:nx+this.w-0.1, y:ny}, {x:nx, y:ny+this.h-0.1}, {x:nx+this.w-0.1, y:ny+this.h-0.1}];
                for (let p of pts) {
                    const tx = Math.floor(p.x/TILE_SIZE), ty = Math.floor(p.y/TILE_SIZE);
                    if (map[ty] && map[ty][tx] === 1) return true;
                }
                return false;
            }
            move(map) {
                if (!this.checkMap(map, this.vx, 0)) this.x += this.vx;
                if (!this.checkMap(map, 0, this.vy)) { this.y += this.vy; this.grounded = false; }
                else {
                    if (this.vy > 0) this.grounded = true;
                    this.vy = 0; this.y = Math.round(this.y);
                }
            }
            draw(ctx) {}
        }

        class Player extends Entity {
            constructor(x, y) {
                super(x, y, 12, 14, 'player');
                this.hp = 100; this.maxHp = 100;
                this.ammo = 100;
                this.maxAmmo = 200;
                this.lastShot = 0;
                this.jumpForce = -7.5;
                this.weapon = WEAPONS.PISTOL;
            }
            update(map, ents) {
                this.vx = 0;
                if (keys.a) { this.vx = -3; }
                if (keys.d) { this.vx = 3; }
                if (keys.space && this.grounded) { this.vy = this.jumpForce; this.grounded = false; }
                this.vy += 0.4; this.vy = Math.min(this.vy, 8);
                this.move(map);

                const cx = Math.floor((this.x+6)/TILE_SIZE), cy = Math.floor((this.y+6)/TILE_SIZE);
                if (map[cy] && map[cy][cx] === 2) this.hit(1);
            }
            tryShoot() {
                if (Date.now() - this.lastShot > this.weapon.rate) {
                    if (this.ammo > 0 || this.weapon.name === 'PISTOL') { // Pistol always fires (but weak if no ammo?) - nah infinite pistol ammo for backup is nice, but sticking to logic
                        if(this.ammo > 0) this.shoot();
                    }
                    this.lastShot = Date.now();
                }
            }
            shoot() {
                this.ammo--;
                const angle = Math.atan2(mouse.worldY - (this.y+6), mouse.worldX - (this.x+6));

                for(let i=0; i<this.weapon.count; i++) {
                    // Spread calculation
                    const a = angle + (Math.random() - 0.5) * this.weapon.spread;

                    let b = new Bullet(this.x+6, this.y+6, Math.cos(a)*this.weapon.speed, Math.sin(a)*this.weapon.speed, true, this.weapon);
                    game.entities.push(b);
                }

                game.shake = this.weapon.name === 'RAILGUN' ? 10 : 3;
                // Recoil
                this.vx -= Math.cos(angle) * (this.weapon.name === 'RAILGUN' ? 5 : 0.5);
                this.vy -= Math.sin(angle) * (this.weapon.name === 'RAILGUN' ? 5 : 0.5);
            }
            addAmmo(amount) { this.ammo = Math.min(this.ammo + amount, this.maxAmmo); }
            heal(amount) { this.hp = Math.min(this.hp + amount, this.maxHp); }
            setWeapon(wName) {
                this.weapon = WEAPONS[wName];
                // Give a little starter ammo for the gun
                this.addAmmo(20);
            }
            hit(d) {
                this.hp -= d; if(this.hp<=0) this.dead = true;
                game.shake = 5;
                for(let i=0; i<3; i++) game.particles.push(new Particle(this.x+6, this.y+6, C.NEON_BLUE));
            }
            draw(ctx) {
                ctx.save();
                ctx.translate(Math.floor(this.x)+6, Math.floor(this.y)+7);
                if (mouse.worldX < this.x) ctx.scale(-1, 1);
                ctx.shadowColor = C.NEON_BLUE;
                ctx.shadowBlur = 10;
                ctx.drawImage(sprites.player, -6, -7);
                ctx.shadowBlur = 0;
                ctx.restore();
            }
        }

        // --- ВРАГИ ---

        class Walker extends Entity {
            constructor(x, y) {
                super(x, y, 12, 12, 'enemy');
                this.hp = 30;
                this.shootTimer = 0;
            }
            update(map, ents) {
                this.vy += 0.4;
                this.move(map);
                if (!game.player.dead) {
                    const dist = Math.hypot(game.player.x - this.x, game.player.y - this.y);
                    if (dist < 300) {
                        if (Date.now() > this.shootTimer && Math.random() < 0.02) {
                            const angle = Math.atan2(game.player.y - this.y, game.player.x - this.x);
                            game.entities.push(new Bullet(this.x+6, this.y+6, Math.cos(angle)*4, Math.sin(angle)*4, false, {dmg:10, color:'red', pierce:true}));
                            this.shootTimer = Date.now() + 1000;
                        }
                    }
                }
            }
            hit(d) { this.hp -= d; if(this.hp<=0) { this.dead = true; for(let i=0; i<5; i++) game.particles.push(new Particle(this.x+6, this.y+6, 'red')); } }
            draw(ctx) { ctx.drawImage(sprites.walker, Math.floor(this.x), Math.floor(this.y)); }
        }

        class Crawler extends Entity {
            constructor(x, y) {
                super(x, y, 10, 6, 'enemy');
                this.hp = 15;
                this.speed = 2.0;
            }
            update(map, ents) {
                this.vy += 0.4;
                if (!game.player.dead) {
                     if (game.player.x < this.x) this.vx = -this.speed;
                     else this.vx = this.speed;
                     if ((this.checkMap(map, this.vx * 4, 0) || (game.player.y < this.y - 30)) && this.grounded) { this.vy = -6; this.grounded = false; }
                     if (Math.abs(this.x - game.player.x) < 10 && Math.abs(this.y - game.player.y) < 10) game.player.hit(2);
                }
                this.move(map);
            }
            hit(d) { this.hp -= d; if(this.hp<=0) { this.dead = true; for(let i=0; i<5; i++) game.particles.push(new Particle(this.x+5, this.y+3, C.ENEMY_CRAWLER)); } }
            draw(ctx) {
                ctx.save(); ctx.translate(Math.floor(this.x)+5, Math.floor(this.y)+3);
                if (this.vx < 0) ctx.scale(-1, 1); ctx.drawImage(sprites.crawler, -5, -3); ctx.restore();
            }
        }

        class Drone extends Entity {
            constructor(x, y) {
                super(x, y, 10, 8, 'enemy');
                this.hp = 20;
                this.shootTimer = 0;
            }
            update(map, ents) {
                if (!game.player.dead) {
                    const dx = game.player.x - this.x;
                    const dy = game.player.y - this.y - 40;
                    this.vx += dx * 0.001; this.vy += dy * 0.001;
                    this.vx *= 0.95; this.vy *= 0.95;
                    this.x += this.vx; this.y += this.vy;
                    if (Date.now() > this.shootTimer && Math.random() < 0.03) {
                        const angle = Math.atan2(game.player.y - this.y, game.player.x - this.x);
                        game.entities.push(new Bullet(this.x+5, this.y+4, Math.cos(angle)*3, Math.sin(angle)*3, false, {dmg:10, color:'red', pierce:true}));
                        this.shootTimer = Date.now() + 1500;
                    }
                }
            }
            hit(d) { this.hp -= d; if(this.hp<=0) { this.dead = true; for(let i=0; i<5; i++) game.particles.push(new Particle(this.x+5, this.y+4, 'cyan')); } }
            draw(ctx) { ctx.drawImage(sprites.drone, Math.floor(this.x), Math.floor(this.y)); }
        }

        class Tank extends Entity {
            constructor(x, y) {
                super(x, y, 14, 14, 'enemy');
                this.hp = 80;
                this.shootTimer = 0;
            }
            update(map, ents) {
                this.vy += 0.4; this.move(map);
                if (!game.player.dead) {
                    const dist = Math.hypot(game.player.x - this.x, game.player.y - this.y);
                    if (dist < 200 && Date.now() > this.shootTimer) {
                        const angle = Math.atan2(game.player.y - this.y, game.player.x - this.x);
                        for(let i=-1; i<=1; i++) {
                             const a = angle + i * 0.2;
                             game.entities.push(new Bullet(this.x+7, this.y+7, Math.cos(a)*3, Math.sin(a)*3, false, {dmg:10, color:'red', pierce:true}));
                        }
                        this.shootTimer = Date.now() + 2500;
                    }
                }
            }
            hit(d) { this.hp -= d; if(this.hp<=0) { this.dead = true; for(let i=0; i<8; i++) game.particles.push(new Particle(this.x+7, this.y+7, C.ENEMY_TANK)); } }
            draw(ctx) { ctx.drawImage(sprites.tank, Math.floor(this.x), Math.floor(this.y)); }
        }

        class Kamikaze extends Entity {
            constructor(x, y) { super(x, y, 10, 10, 'enemy'); this.hp = 10; }
            update(map, ents) {
                if (!game.player.dead) {
                    const angle = Math.atan2(game.player.y - this.y, game.player.x - this.x);
                    this.vx = Math.cos(angle) * 2.5; this.vy = Math.sin(angle) * 2.5;
                    this.x += this.vx; this.y += this.vy;
                    if (Math.hypot(game.player.x - this.x, game.player.y - this.y) < 15) {
                        game.player.hit(20); this.dead = true;
                        game.particles.push(new Particle(this.x, this.y, 'orange'));
                    }
                }
            }
            hit(d) { this.hp -= d; if(this.hp<=0) { this.dead = true; for(let i=0; i<5; i++) game.particles.push(new Particle(this.x, this.y, 'orange')); } }
            draw(ctx) { ctx.drawImage(sprites.kami, Math.floor(this.x), Math.floor(this.y)); }
        }

        // --- PICKUPS ---
        class BasePickup extends Entity {
            constructor(x, y, type, wName) {
                super(x+3, y+6, 10, 10, 'pickup');
                this.baseY = y+6;
                this.bob = Math.random()*100;
                this.life = 1000;
                this.pType = type; // ammo, health, weapon
                this.wName = wName;
            }
            update(map, ents) {
                this.y = this.baseY + Math.sin((Date.now()+this.bob)/300)*3;
                this.life--; if(this.life<=0) this.dead = true;
                if(!game.player.dead && this.x < game.player.x+game.player.w && this.x+this.w > game.player.x && this.y < game.player.y+game.player.h && this.y+this.h > game.player.y) {
                    this.dead = true;
                    if(this.pType === 'ammo') { game.player.addAmmo(15); for(let i=0;i<5;i++) game.particles.push(new Particle(this.x,this.y,C.NEON_YELLOW)); }
                    if(this.pType === 'health') { game.player.heal(30); for(let i=0;i<5;i++) game.particles.push(new Particle(this.x,this.y,C.NEON_PINK)); }
                    if(this.pType === 'weapon') { game.player.setWeapon(this.wName); for(let i=0;i<10;i++) game.particles.push(new Particle(this.x,this.y,C.NEON_BLUE)); }
                }
            }
            draw(ctx) {
                if(this.life<100 && Math.floor(Date.now()/50)%2==0) return;
                let s;
                if(this.pType==='ammo') s=sprites.ammo;
                else if(this.pType==='health') s=sprites.health;
                else s=sprites.weapon; // Use weapon crate

                ctx.shadowBlur=5;
                ctx.shadowColor = this.pType==='weapon' ? C.NEON_BLUE : (this.pType==='ammo'?C.NEON_YELLOW:C.NEON_PINK);
                ctx.drawImage(s, Math.floor(this.x), Math.floor(this.y));
                ctx.shadowBlur=0;
            }
        }
        class AmmoPickup extends BasePickup { constructor(x,y) { super(x,y,'ammo'); } }
        class HealthPickup extends BasePickup { constructor(x,y) { super(x,y,'health'); } }
        class WeaponPickup extends BasePickup { constructor(x,y,wName) { super(x,y,'weapon', wName); } }

        class Bullet extends Entity {
            constructor(x, y, vx, vy, isPlayer, props) {
                super(x-2, y-2, 4, 4, 'bullet');
                this.vx = vx; this.vy = vy;
                this.isPlayer = isPlayer;
                this.life = 80;
                this.dmg = props.dmg;
                this.color = props.color;
                this.pierce = props.pierce || false;
                this.homing = props.homing || false;
            }
            update(map, ents) {
                // Homing Logic
                if(this.homing && this.life > 10) {
                    let target = null;
                    let minDist = 200;
                    for(let e of ents) {
                        if(e.type === 'enemy') {
                            const d = Math.hypot(e.x-this.x, e.y-this.y);
                            if(d < minDist) { minDist = d; target = e; }
                        }
                    }
                    if(target) {
                        const angle = Math.atan2(target.y - this.y, target.x - this.x);
                        // Steer
                        this.vx += Math.cos(angle) * 0.5;
                        this.vy += Math.sin(angle) * 0.5;
                        // Clamp speed
                        const speed = Math.hypot(this.vx, this.vy);
                        if(speed > 6) { this.vx *= 0.9; this.vy *= 0.9; }
                    }
                }

                this.x += this.vx; this.y += this.vy; this.life--;

                // Wall Collision
                if(this.life<=0 || (!this.pierce && this.checkMap(map,0,0))) {
                    this.dead = true;
                    for(let i=0; i<3; i++) game.particles.push(new Particle(this.x, this.y, '#fff'));
                    return;
                }

                // Hit logic
                for(let e of ents) {
                    if (e === this || e.type==='bullet' || e.type==='pickup') continue;
                    if (this.isPlayer && e.type==='player') continue;
                    if (!this.isPlayer && e.type==='enemy') continue;

                    if (this.x < e.x+e.w && this.x+this.w > e.x && this.y < e.y+e.h && this.y+this.h > e.y) {
                        if(e.hit) e.hit(this.dmg);
                        if(!this.pierce) { this.dead = true; return; }
                    }
                }
                if (!this.isPlayer && !game.player.dead) {
                     if (this.x < game.player.x+game.player.w && this.x+this.w > game.player.x &&
                         this.y < game.player.y+game.player.h && this.y+this.h > game.player.y) {
                         game.player.hit(this.dmg);
                         this.dead = true;
                     }
                }
            }
            draw(ctx) {
                ctx.fillStyle = this.color;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 5;
                ctx.fillRect(Math.floor(this.x), Math.floor(this.y), 4, 4);
                ctx.shadowBlur = 0;
            }
        }

        class Particle {
            constructor(x, y, c) {
                this.x = x; this.y = y; this.c = c;
                this.vx = (Math.random()-0.5)*5; this.vy = (Math.random()-0.5)*5;
                this.life = 1.0;
            }
            update() { this.x+=this.vx; this.y+=this.vy; this.life-=0.05; }
            draw(ctx) {
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.c;
                ctx.fillRect(Math.floor(this.x), Math.floor(this.y), 2, 2);
                ctx.globalAlpha = 1;
            }
        }

        const game = new Game();

        window.addEventListener('keydown', e => {
            if(e.key==='w'||e.key==='ArrowUp') keys.w=true;
            if(e.key==='a'||e.key==='ArrowLeft') keys.a=true;
            if(e.key==='s'||e.key==='ArrowDown') keys.s=true;
            if(e.key==='d'||e.key==='ArrowRight') keys.d=true;
            if(e.code==='Space') keys.space=true;
        });
        window.addEventListener('keyup', e => {
            if(e.key==='w'||e.key==='ArrowUp') keys.w=false;
            if(e.key==='a'||e.key==='ArrowLeft') keys.a=false;
            if(e.key==='s'||e.key==='ArrowDown') keys.s=false;
            if(e.key==='d'||e.key==='ArrowRight') keys.d=false;
            if(e.code==='Space') keys.space=false;
        });
        window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
        window.addEventListener('mousedown', () => mouse.down = true);
        window.addEventListener('mouseup', () => mouse.down = false);

        document.getElementById('playBtn').addEventListener('click', () => game.startGame());
        document.getElementById('retryBtn').addEventListener('click', () => game.startGame());

    })();
    </script>
</body>
</html>