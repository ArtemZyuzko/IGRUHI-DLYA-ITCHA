<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PROJECT: OUTBREAK [FINAL]</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Press Start 2P', cursive;
            cursor: none;
            image-rendering: pixelated;
        }

        /* Прицел */
        #cursor {
            position: fixed;
            width: 24px;
            height: 24px;
            border: 2px solid #00ffaa;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 1000;
            box-shadow: 0 0 10px #00ffaa;
            transition: transform 0.05s;
        }
        #cursor::before { content: ''; position: absolute; top: 11px; left: 0; width: 100%; height: 2px; background: #00ffaa; }
        #cursor::after { content: ''; position: absolute; top: 0; left: 11px; width: 2px; height: 100%; background: #00ffaa; }
        #cursor.shooting { transform: translate(-50%, -50%) scale(1.5); border-color: #fff; }

        /* UI */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; padding: 30px; box-sizing: border-box;
            display: flex; flex-direction: column; justify-content: space-between; z-index: 100;
        }

        .hud-panel {
            background: #000;
            border: 4px solid #334433;
            padding: 15px;
            box-shadow: 5px 5px 0px #111;
            width: fit-content;
        }

        .bar-wrap { margin-top: 10px; width: 250px; background: #222; height: 20px; position: relative; border: 2px solid #fff; overflow: hidden; }
        .bar-fill { height: 100%; transition: width 0.1s; }
        .hp-fill { background: #e74c3c; }
        .ammo-fill { background: #f1c40f; }
        .bar-text { position: absolute; top: 4px; left: 5px; font-size: 10px; color: #fff; z-index: 2; text-shadow: 1px 1px 0 #000; }

        .weapon-title { color: #00ffaa; font-size: 16px; margin-bottom: 5px; text-transform: uppercase; text-shadow: 2px 2px 0 #000; }

        /* Эффект ранения (красная виньетка) */
        #damage-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 50;
            background: radial-gradient(circle, transparent 50%, rgba(255,0,0,0.4) 100%);
            opacity: 0;
            transition: opacity 0.1s;
        }

        .overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 200; pointer-events: auto; cursor: default;
        }

        h1 { color: #e74c3c; font-size: 40px; text-shadow: 4px 4px 0 #550000; margin-bottom: 40px; text-align: center; line-height: 1.5; }

        .btn {
            background: #e74c3c; color: #fff; border: 4px solid #fff;
            padding: 20px 40px; font-family: inherit; font-size: 18px;
            cursor: pointer; text-transform: uppercase;
            box-shadow: 6px 6px 0 #550000;
        }
        .btn:hover { transform: translate(-2px, -2px); box-shadow: 8px 8px 0 #550000; }
        .btn:active { transform: translate(4px, 4px); box-shadow: 0 0 0; }

        #boss-alert {
            display: none; position: absolute; top: 20%; left: 50%;
            transform: translate(-50%, -50%); color: #ff0055;
            font-size: 30px; text-shadow: 3px 3px 0 #000;
            animation: blink 0.2s infinite alternate;
        }
        @keyframes blink { from {opacity: 1;} to {opacity: 0;} }
    </style>
</head>
<body>

    <div id="damage-overlay"></div>
    <div id="cursor"></div>

    <div id="start-screen" class="overlay">
        <h1>TACTICAL<br>OPS: ZOMBIE</h1>
        <button class="btn" onclick="startGame()">DEPLOY</button>
        <div style="margin-top: 20px; color: #888; font-size: 10px;">WASD - MOVE | CLICK - FIRE</div>
    </div>

    <div id="game-over-screen" class="overlay" style="display: none;">
        <h1>K.I.A.</h1>
        <div style="color: #fff; margin-bottom: 20px;">SCORE: <span id="final-score" style="color: #00ffaa">0</span></div>
        <button class="btn" onclick="startGame()">REDEPLOY</button>
    </div>

    <div id="ui-layer" style="display: none;">
        <div class="hud-panel">
            <div class="weapon-title" id="ui-weapon">PISTOL</div>
            <div class="bar-wrap">
                <div class="bar-text">INTEGRITY</div>
                <div id="hp-bar" class="bar-fill hp-fill" style="width: 100%;"></div>
            </div>
            <div class="bar-wrap">
                <div class="bar-text">AMMO</div>
                <div id="ammo-bar" class="bar-fill ammo-fill" style="width: 100%;"></div>
            </div>
        </div>

        <div class="hud-panel" style="text-align: right;">
            <div style="color: #00ffaa; font-size: 20px;" id="ui-score">0</div>
            <div style="color: #666; font-size: 12px; margin-top: 5px;" id="ui-time">00:00</div>
        </div>
    </div>

    <div id="boss-alert">⚠ BOSS DETECTED ⚠</div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const cursor = document.getElementById('cursor');
        const damageOverlay = document.getElementById('damage-overlay');

        ctx.imageSmoothingEnabled = false;

        // UI
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const uiLayer = document.getElementById('ui-layer');
        const hpBar = document.getElementById('hp-bar');
        const ammoBar = document.getElementById('ammo-bar');
        const uiWeapon = document.getElementById('ui-weapon');
        const uiScore = document.getElementById('ui-score');
        const uiTime = document.getElementById('ui-time');
        const bossAlert = document.getElementById('boss-alert');
        const finalScore = document.getElementById('final-score');

        // --- CONFIG ---
        const WORLD_W = 2000;
        const WORLD_H = 2000;
        const TILE_SIZE = 80;

        const WEAPONS = {
            pistol: { name: 'M9 PISTOL', dmg: 30, rate: 350, spread: 0.05, speed: 18, color: '#f1c40f', maxAmmo: Infinity, count: 1, auto: false },
            shotgun: { name: 'SPAS-12', dmg: 18, rate: 900, spread: 0.3, speed: 16, color: '#e67e22', maxAmmo: 24, count: 6, auto: false },
            rifle: { name: 'M4 CARBINE', dmg: 20, rate: 100, spread: 0.12, speed: 22, color: '#00ffaa', maxAmmo: 120, count: 1, auto: true },
            railgun: { name: 'PROTOTYPE', dmg: 300, rate: 1500, spread: 0, speed: 40, color: '#00ffff', maxAmmo: 10, count: 1, auto: false, pierce: true }
        };

        let active = false;
        let lastTime = 0;
        let gameTimer = 0;
        let score = 0;
        let camera = { x: 0, y: 0 };
        let shake = 0;
        let damageFlash = 0; // Интенсивность красной вспышки

        let player;
        let bullets = [];
        let enemies = [];
        let particles = [];
        let decals = [];
        let items = [];
        let texts = [];
        let obstacles = [];
        let dust = [];

        const keys = {};
        const mouse = { x: 0, y: 0, wx: 0, wy: 0, down: false };

        function rand(min, max) { return Math.random() * (max - min) + min; }

        function checkRectCollide(x, y, r, rect) {
            return x > rect.x - r && x < rect.x + rect.w + r && y > rect.y - r && y < rect.y + rect.h + r;
        }

        function resolveCollision(entity, radius) {
            entity.x = Math.max(radius, Math.min(WORLD_W - radius, entity.x));
            entity.y = Math.max(radius, Math.min(WORLD_H - radius, entity.y));

            for(let obs of obstacles) {
                if(checkRectCollide(entity.x, entity.y, radius, obs)) {
                    let cx = obs.x + obs.w/2;
                    let cy = obs.y + obs.h/2;
                    let dx = entity.x - cx;
                    let dy = entity.y - cy;
                    if(Math.abs(dx) > Math.abs(dy)) {
                        entity.x = dx > 0 ? obs.x + obs.w + radius : obs.x - radius;
                    } else {
                        entity.y = dy > 0 ? obs.y + obs.h + radius : obs.y - radius;
                    }
                }
            }
        }

        function startGame() {
            active = true; score = 0; gameTimer = 0; lastTime = Date.now();
            player = new Player(); bullets = []; enemies = []; items = []; particles = []; texts = []; decals = [];
            generateMap(); updateUI();
            startScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            uiLayer.style.display = 'flex';
            damageFlash = 0;
            loop();
        }

        function endGame() {
            active = false;
            uiLayer.style.display = 'none';
            gameOverScreen.style.display = 'flex';
            finalScore.innerText = `SCORE: ${score}`;
        }

        class Obstacle {
            constructor(x, y, w, h) {
                this.x = x; this.y = y; this.w = w; this.h = h;
            }
            draw() {
                ctx.fillStyle = '#222';
                ctx.fillRect(this.x + 8, this.y + 8, this.w, this.h);
                ctx.fillStyle = '#34495e';
                ctx.fillRect(this.x, this.y + 10, this.w, this.h);
                ctx.fillStyle = '#455a64';
                ctx.fillRect(this.x, this.y, this.w, this.h);

                ctx.fillStyle = '#2c3e50';
                ctx.fillRect(this.x+4, this.y+4, 8, 8);
                ctx.fillRect(this.x+this.w-12, this.y+4, 8, 8);
                ctx.fillRect(this.x+4, this.y+this.h-12, 8, 8);
                ctx.fillRect(this.x+this.w-12, this.y+this.h-12, 8, 8);

                ctx.fillRect(this.x + this.w/2 - 4, this.y + 20, 8, this.h - 40);
                ctx.fillRect(this.x + 20, this.y + this.h/2 - 4, this.w - 40, 8);
            }
        }

        class Player {
            constructor() {
                this.x = WORLD_W/2; this.y = WORLD_H/2;
                this.hp = 100; this.maxHp = 100;
                this.speed = 6;
                this.angle = 0;
                this.weapon = { ...WEAPONS.pistol, ammo: Infinity };
                this.lastShot = 0;
                this.animTimer = 0;
            }
            update() {
                let dx = 0, dy = 0;
                if(keys['w'] || keys['ц']) dy = -1;
                if(keys['s'] || keys['ы']) dy = 1;
                if(keys['a'] || keys['ф']) dx = -1;
                if(keys['d'] || keys['в']) dx = 1;

                if(dx || dy) {
                    const l = Math.hypot(dx, dy);
                    this.x += (dx/l) * this.speed;
                    this.y += (dy/l) * this.speed;
                    this.animTimer += 0.2;
                } else {
                    this.animTimer = 0;
                }

                resolveCollision(this, 15);
                this.angle = Math.atan2(mouse.wy - this.y, mouse.wx - this.x);

                if(mouse.down) {
                    if(this.weapon.auto || !this.clicked) this.shoot();
                    this.clicked = true;
                } else this.clicked = false;
            }
            shoot() {
                const now = Date.now();
                if(now - this.lastShot < this.weapon.rate) return;
                if(this.weapon.ammo <= 0 && this.weapon.maxAmmo !== Infinity) {
                    this.weapon = {...WEAPONS.pistol, ammo: Infinity};
                    addText(this.x, this.y, "NO AMMO", "#fff");
                    updateUI();
                    return;
                }

                this.lastShot = now;
                if(this.weapon.maxAmmo !== Infinity) this.weapon.ammo--;
                shake = 4;
                cursor.classList.add('shooting');
                setTimeout(()=>cursor.classList.remove('shooting'), 50);

                const bx = this.x + Math.cos(this.angle) * 35 + Math.cos(this.angle + Math.PI/2) * 8;
                const by = this.y + Math.sin(this.angle) * 35 + Math.sin(this.angle + Math.PI/2) * 8;

                particles.push(new Particle(bx, by, '#ffff00', 4, 0));

                for(let i=0; i<this.weapon.count; i++) {
                    const spr = (Math.random()-0.5)*this.weapon.spread;
                    bullets.push(new Bullet(bx, by, this.angle + spr, this.weapon));
                }
                updateUI();
            }
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                const walkOffset = Math.sin(this.animTimer) * 6;
                ctx.fillStyle = '#1e272e';
                ctx.fillRect(-10 + walkOffset, -12, 14, 8);
                ctx.fillRect(-10 - walkOffset, 4, 14, 8);

                ctx.fillStyle = '#3498db';
                ctx.fillRect(-12, -14, 24, 28);
                ctx.fillStyle = '#2980b9';
                ctx.fillRect(-8, -10, 16, 20);

                ctx.fillStyle = '#3498db';
                ctx.fillRect(0, -18, 12, 8);
                ctx.fillRect(0, 10, 12, 8);

                ctx.fillStyle = '#2980b9';
                ctx.save();
                ctx.translate(6, -14);
                ctx.rotate(-0.3);
                ctx.fillRect(0, 0, 18, 6);
                ctx.restore();

                ctx.save();
                ctx.translate(6, 10);
                ctx.rotate(0.3);
                ctx.fillRect(0, -6, 18, 6);
                ctx.restore();

                ctx.fillStyle = '#111';
                ctx.fillRect(18, -4, 30, 8);
                ctx.fillStyle = '#333';
                ctx.fillRect(22, 4, 6, 6);
                ctx.fillStyle = '#555';
                ctx.fillRect(30, -4, 14, 8);

                ctx.fillStyle = '#2c3e50';
                ctx.fillRect(-8, -9, 18, 18);

                ctx.fillStyle = '#333';
                ctx.fillRect(0, -9, 4, 18);
                ctx.fillStyle = '#00ffaa';
                ctx.fillRect(4, -4, 4, 8);

                ctx.restore();
            }
            takeDamage(amount) {
                this.hp -= amount;
                shake = 6; // Сильная тряска
                damageFlash = 0.8; // Красная вспышка

                // Кровь из игрока
                if(Math.random() < 0.2) spawnBlood(this.x, this.y, 1);

                updateUI();
                if(this.hp <= 0) endGame();
            }
        }

        class Enemy {
            constructor(x, y, type) {
                this.x = x; this.y = y; this.type = type;
                this.pushX = 0; this.pushY = 0;
                this.flashTime = 0;
                this.stunTimer = 0;

                if(type === 'boss') {
                    this.hp = 1500; this.speed = 1.5; this.rad = 40; this.color = '#8e44ad'; this.score = 1000;
                } else if (type === 'runner') {
                    this.hp = 20; this.speed = 4.5; this.rad = 12; this.color = '#e67e22'; this.score = 20;
                } else {
                    this.hp = 35; this.speed = 2; this.rad = 15; this.color = '#27ae60'; this.score = 10;
                }
                this.maxHp = this.hp;
                this.anim = Math.random();
            }
            update() {
                const a = Math.atan2(player.y - this.y, player.x - this.x);

                let currentSpeed = (this.stunTimer > 0) ? 0 : this.speed;
                if(this.stunTimer > 0) this.stunTimer--;

                this.x += Math.cos(a) * currentSpeed + this.pushX;
                this.y += Math.sin(a) * currentSpeed + this.pushY;

                this.pushX *= 0.8; this.pushY *= 0.8;

                if (currentSpeed > 0) this.anim += 0.15;
                if(this.flashTime > 0) this.flashTime--;

                resolveCollision(this, this.rad);

                // Нанесение урона игроку
                if(Math.hypot(player.x - this.x, player.y - this.y) < this.rad + 20) {
                    player.takeDamage(0.5);
                }
            }
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                const a = Math.atan2(player.y - this.y, player.x - this.x);
                ctx.rotate(a);

                if(this.flashTime > 0) {
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(-15, -15, 30, 30);
                } else {
                    const walk = Math.sin(this.anim) * 4;

                    ctx.fillStyle = this.color;
                    ctx.fillRect(10, -14, 14, 6);
                    ctx.fillRect(10, 8, 14, 6);

                    ctx.fillStyle = this.color;
                    ctx.filter = 'brightness(0.8)';
                    ctx.fillRect(-15, -15, 30, 30);
                    ctx.filter = 'none';

                    ctx.fillStyle = this.color;
                    ctx.fillRect(-5, -10, 20, 20);

                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(8, -6, 4, 4);
                    ctx.fillRect(8, 2, 4, 4);
                }

                if(this.type === 'boss') {
                    ctx.rotate(-a);
                    ctx.fillStyle = 'red'; ctx.fillRect(-30, -50, 60, 6);
                    ctx.fillStyle = '#0f0'; ctx.fillRect(-30, -50, 60*(this.hp/this.maxHp), 6);
                }

                ctx.restore();
            }
            hit(dmg, ang) {
                this.hp -= dmg;
                this.pushX = Math.cos(ang) * -5;
                this.pushY = Math.sin(ang) * -5;
                this.flashTime = 3;
                this.stunTimer = 10;
                spawnBlood(this.x, this.y, 3);

                if(this.hp <= 0) {
                    score += this.score;
                    spawnBlood(this.x, this.y, 15, true);

                    if(Math.random() < 0.2 || this.type === 'boss') {
                        const r = Math.random();
                        let type = 'ammo';

                        if (r < 0.5) type = 'ammo';
                        else if (r < 0.75) type = 'medkit';
                        else {
                             const w = ['shotgun','rifle','railgun'];
                             type = w[Math.floor(Math.random()*w.length)];
                        }

                        if(this.type === 'boss') {
                            items.push({x: this.x, y: this.y, type: 'railgun', life: 1000});
                            items.push({x: this.x + 30, y: this.y, type: 'medkit', life: 1000});
                        } else {
                            items.push({x: this.x, y: this.y, type: type, life: 1000});
                        }
                    }
                    return true;
                }
                return false;
            }
        }

        class Bullet {
            constructor(x, y, a, w) {
                this.x = x; this.y = y; this.vx = Math.cos(a)*w.speed; this.vy = Math.sin(a)*w.speed;
                this.dmg = w.dmg; this.pierce = w.pierce; this.color = w.color;
                this.life = 100;
            }
            update() {
                this.x += this.vx; this.y += this.vy;
                this.life--;

                for(let obs of obstacles) {
                    if(checkRectCollide(this.x, this.y, 2, obs)) {
                        this.life = 0;
                        particles.push(new Particle(this.x, this.y, '#fff', 2, 0));
                        return;
                    }
                }
            }
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(Math.atan2(this.vy, this.vx));
                ctx.fillStyle = this.color;
                ctx.fillRect(-8, -2, 16, 4);
                ctx.restore();
            }
        }

        class Particle {
            constructor(x, y, c, s, spd) {
                this.x = x; this.y = y; this.color = c; this.size = s;
                let a = Math.random()*6.28; let v = Math.random()*spd;
                this.vx = Math.cos(a)*v; this.vy = Math.sin(a)*v;
                this.life = 1.0;
            }
            update() { this.x+=this.vx; this.y+=this.vy; this.life-=0.05; }
            draw() {
                ctx.globalAlpha = this.life; ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.globalAlpha = 1;
            }
        }

        function generateMap() {
            obstacles = [];
            obstacles.push(new Obstacle(-50, -50, WORLD_W+100, 50));
            obstacles.push(new Obstacle(-50, WORLD_H, WORLD_W+100, 50));
            obstacles.push(new Obstacle(-50, 0, 50, WORLD_H));
            obstacles.push(new Obstacle(WORLD_W, 0, 50, WORLD_H));

            for(let i=0; i<40; i++) {
                let w = rand(80, 200);
                let h = rand(80, 200);
                let x = rand(100, WORLD_W - w - 100);
                let y = rand(100, WORLD_H - h - 100);

                x = Math.floor(x/40)*40; y = Math.floor(y/40)*40;
                w = Math.floor(w/40)*40; h = Math.floor(h/40)*40;

                if(Math.hypot(x - WORLD_W/2, y - WORLD_H/2) > 400) {
                    obstacles.push(new Obstacle(x, y, w, h));
                }
            }

            dust = [];
            for(let i=0; i<50; i++) {
                dust.push({x: rand(0, WORLD_W), y: rand(0, WORLD_H), size: rand(2,4), vx: rand(-0.2, 0.2), vy: rand(-0.2, 0.2)});
            }
        }

        function drawFloor() {
            const startX = Math.floor(camera.x / TILE_SIZE) * TILE_SIZE;
            const startY = Math.floor(camera.y / TILE_SIZE) * TILE_SIZE;

            ctx.lineWidth = 2;
            ctx.strokeStyle = '#111';

            for(let x = startX; x < camera.x + canvas.width + TILE_SIZE; x += TILE_SIZE) {
                for(let y = startY; y < camera.y + canvas.height + TILE_SIZE; y += TILE_SIZE) {
                    const noise = Math.sin(x * 12.9898 + y * 78.233) * 43758.5453;
                    const val = noise - Math.floor(noise);

                    if(val > 0.8) ctx.fillStyle = '#0f0f0f';
                    else ctx.fillStyle = '#0a0a0a';

                    ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                    ctx.strokeRect(x, y, TILE_SIZE, TILE_SIZE);

                    if(val > 0.95) {
                        ctx.fillStyle = '#1a1a1a';
                        ctx.fillRect(x + 10, y + 10, TILE_SIZE-20, TILE_SIZE-20);
                        ctx.fillStyle = '#000';
                        ctx.fillRect(x+20, y+15, 40, 5);
                        ctx.fillRect(x+20, y+35, 40, 5);
                        ctx.fillRect(x+20, y+55, 40, 5);
                    }
                }
            }
        }

        function spawnBlood(x, y, n, stain) {
            for(let i=0; i<n; i++) particles.push(new Particle(x, y, '#c0392b', rand(4,8), 5));
            if(stain) decals.push({x: x+rand(-10,10), y: y+rand(-10,10), s: rand(20,40), a: 0.9});
            if(decals.length > 200) decals.shift();
        }

        function addText(x, y, t, c) { texts.push({x, y, t, c, l: 50}); }

        function updateUI() {
            const w = player.weapon;
            uiWeapon.innerText = w.name;
            uiWeapon.style.color = w.color;

            hpBar.style.width = (player.hp / player.maxHp * 100) + '%';

            if(w.maxAmmo === Infinity) {
                ammoBar.style.width = '100%';
            } else {
                ammoBar.style.width = Math.min(100, (w.ammo / w.maxAmmo * 100)) + '%';
            }

            uiScore.innerText = score;

            // Low HP Effect
            if(player.hp < 30) {
                damageOverlay.style.opacity = 0.3 + Math.sin(Date.now()/150) * 0.2;
            } else {
                damageOverlay.style.opacity = 0;
            }
        }

        function loop() {
            if(!active) return;
            requestAnimationFrame(loop);

            const now = Date.now();
            if(now - lastTime > 1000) {
                lastTime = now; gameTimer++;
                let m = Math.floor(gameTimer/60); let s = gameTimer%60;
                uiTime.innerText = `${m}:${s<10?'0'+s:s}`;

                let count = 1 + Math.floor(gameTimer/15);
                for(let i=0; i<count; i++) {
                    let ang = Math.random()*6.28;
                    let dist = 900;
                    let ex = player.x + Math.cos(ang)*dist;
                    let ey = player.y + Math.sin(ang)*dist;
                    let type = (gameTimer>30 && Math.random()>0.7) ? 'runner' : 'zombie';
                    enemies.push(new Enemy(ex, ey, type));
                }

                if(gameTimer>0 && gameTimer%60===0) {
                    bossAlert.style.display='block';
                    setTimeout(()=>bossAlert.style.display='none',3000);
                    let ang = Math.random()*6.28;
                    enemies.push(new Enemy(player.x+Math.cos(ang)*800, player.y+Math.sin(ang)*800, 'boss'));
                }
            }

            let sx = 0, sy = 0;
            if(shake > 0) { sx = (Math.random()-0.5)*shake; sy = (Math.random()-0.5)*shake; shake*=0.9; }

            camera.x += (player.x - canvas.width/2 - camera.x) * 0.1;
            camera.y += (player.y - canvas.height/2 - camera.y) * 0.1;

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            ctx.translate(-camera.x + sx, -camera.y + sy);

            drawFloor();

            for(let d of decals) {
                ctx.globalAlpha = d.a; ctx.fillStyle = '#500';
                ctx.fillRect(d.x, d.y, d.s, d.s);
            }
            ctx.globalAlpha = 1;

            items.forEach((it, i) => {
                let bob = Math.sin(Date.now()/200)*5;

                if (it.type === 'ammo') {
                    ctx.fillStyle = '#f1c40f';
                    ctx.fillRect(it.x-12, it.y-12+bob, 24, 24);
                    ctx.fillStyle = '#000';
                    ctx.font = 'bold 10px monospace';
                    ctx.fillText('AMMO', it.x-11, it.y+bob+4);
                } else if (it.type === 'medkit') {
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(it.x-12, it.y-12+bob, 24, 24);
                    ctx.fillStyle = '#f00';
                    ctx.fillRect(it.x-4, it.y-8+bob, 8, 16);
                    ctx.fillRect(it.x-8, it.y-4+bob, 16, 8);
                } else {
                    ctx.fillStyle = '#00ffaa';
                    ctx.fillRect(it.x-12, it.y-12+bob, 24, 24);
                    ctx.fillStyle = '#000';
                    ctx.fillText('GUN', it.x-10, it.y+bob+4);
                }

                if(Math.hypot(player.x-it.x, player.y-it.y) < 40) {
                    let picked = false;

                    if(it.type === 'ammo') {
                        if(player.weapon.maxAmmo !== Infinity) {
                            if (player.weapon.ammo < player.weapon.maxAmmo) {
                                player.weapon.ammo = Math.min(player.weapon.ammo + 100, player.weapon.maxAmmo * 2);
                                addText(player.x, player.y, '+AMMO', '#f1c40f');
                                picked = true;
                            } else {
                                addText(player.x, player.y, 'FULL', '#fff');
                            }
                        } else {
                            addText(player.x, player.y, 'FULL', '#fff');
                        }
                    } else if(it.type === 'medkit') {
                        if (player.hp < player.maxHp) {
                            player.hp = Math.min(100, player.hp + 50);
                            addText(player.x,player.y,'+HP','#0f0');
                            picked = true;
                        } else {
                            addText(player.x, player.y, 'HP FULL', '#fff');
                        }
                    } else {
                         if(player.weapon.name === WEAPONS[it.type].name && player.weapon.maxAmmo !== Infinity) {
                            if (player.weapon.ammo < player.weapon.maxAmmo * 2) {
                                player.weapon.ammo += WEAPONS[it.type].maxAmmo;
                                addText(player.x, player.y, '+AMMO', '#fff');
                                picked = true;
                            } else {
                                addText(player.x, player.y, 'FULL', '#fff');
                            }
                         } else {
                            player.weapon = {...WEAPONS[it.type], ammo: WEAPONS[it.type].maxAmmo};
                            addText(player.x, player.y, player.weapon.name, '#00ffaa');
                            picked = true;
                         }
                    }

                    if (picked) {
                        items.splice(i, 1);
                        updateUI();
                    }
                }
            });

            player.update();
            player.draw();

            bullets.forEach((b, i) => {
                b.update(); b.draw();
                if(b.life<=0 || b.x<0 || b.x>WORLD_W || b.y<0 || b.y>WORLD_H) { bullets.splice(i,1); return; }

                for(let j=enemies.length-1; j>=0; j--) {
                    if(Math.hypot(b.x-enemies[j].x, b.y-enemies[j].y) < enemies[j].rad+10) {
                        let dead = enemies[j].hit(b.dmg, Math.atan2(b.vy, b.vx));
                        if(dead) enemies.splice(j,1);
                        if(!b.pierce) { b.life=0; break; }
                    }
                }
            });

            enemies.forEach(e => { e.update(); e.draw(); });
            obstacles.forEach(o => o.draw());

            particles.forEach((p, i) => { p.update(); p.draw(); if(p.life<=0) particles.splice(i,1); });
            texts.forEach((t, i) => { t.y-=0.5; t.l--; ctx.fillStyle=t.c; ctx.font="10px 'Press Start 2P'"; ctx.fillText(t.t, t.x, t.y); if(t.l<=0) texts.splice(i,1); });

            ctx.fillStyle = 'rgba(200, 255, 255, 0.05)';
            dust.forEach(d => {
                d.x += d.vx; d.y += d.vy;
                if(d.x < 0) d.x = WORLD_W; if(d.x > WORLD_W) d.x = 0;
                if(d.y < 0) d.y = WORLD_H; if(d.y > WORLD_H) d.y = 0;
                ctx.fillRect(d.x, d.y, d.size, d.size);
            });

            ctx.restore();

            // Lighting
            const cx = player.x - camera.x + sx;
            const cy = player.y - camera.y + sy;
            const grad = ctx.createRadialGradient(cx, cy, 150, cx, cy, 800);
            grad.addColorStop(0, 'rgba(0,0,0,0)');
            grad.addColorStop(1, 'rgba(0,0,0,0.95)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,canvas.width,canvas.height);

            // Damage Flash
            if(damageFlash > 0) {
                ctx.fillStyle = `rgba(255, 0, 0, ${damageFlash * 0.4})`;
                ctx.fillRect(0,0,canvas.width,canvas.height);
                damageFlash -= 0.05;
            }
        }

        window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
        window.addEventListener('mousedown', () => mouse.down = true);
        window.addEventListener('mouseup', () => mouse.down = false);
        window.addEventListener('mousemove', e => {
            mouse.x = e.clientX; mouse.y = e.clientY;
            mouse.wx = mouse.x + camera.x; mouse.wy = mouse.y + camera.y;
            cursor.style.left = e.clientX + 'px'; cursor.style.top = e.clientY + 'px';
        });
        window.addEventListener('resize', () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; });
        canvas.width = window.innerWidth; canvas.height = window.innerHeight;

    </script>
</body>
</html>